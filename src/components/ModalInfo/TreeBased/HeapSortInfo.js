import TextItem from "../TextItem"
import HorizontalLine from "../HorizontalLine"

function HeapSortInfo() {
    return (
        <>
            <TextItem>
                Сортування пірамідою (Heapsort, Сортування купою) використовує двійкову купу.
                Двійкова купа (англ. binary heap) — це структура даних, яку можна розглядати як майже повне двійкове дерево, 
                у якому значення в будь-якій вершині не менші за значення їх нащадків.
            </TextItem>
            <TextItem>
                Майже повне двійкове дерево (англ. almost complete binary tree) - це таке двійкове дерево, 
                в якому кожен рівень (окрім, можливо, останнього) повністю заповнений, а всі вузли останнього рівня максимально розміщені ліворуч.
            </TextItem>

            <TextItem>
                Щоб побудувати двійкову купу (яку також називають пірамідою, звікди й пішла назва алгоритму), розпочнемо з пустого дерева.
                По черзі кожен елемент масиву будемо добавляти у кінець дерева, викликаючи після цього процедуру просіювання вверх.
                Добавивши новий елемент в кінець дерева, ми ломаємо двійкову купу 
                (а саме дану умову: значення в будь-якій вершині не менші за значення їх нащадків).
                Проте виконавши процедуру просіювання вверх, ми знову відбудуємо дерево, яке буде задовільняти дану умову.
            </TextItem>
            
            <TextItem>
                На даному етапі ми маємо побудовану двійкову купу. З визначення двійкової купи ми знаємо, що корінь даного дерева має найбільше значення з усього дерева.
                Тому ми міняємо місцями останній елемент дерева та його корінь.
                Тепер останній елемент дерева - найбільший. Ми можемо вважати даний елемент відсортованим, тому вилучаємо його з дерева.
                Оскільки минулий останній елемент дерева тепер став коренем, ми знову зломали двійкову купу.
                Проте виконавши процедуру просіювання вниз над кореневим елементом, ми можемо з легкістю відновити двійкову купу.
            </TextItem>
            <TextItem>
                Даний алгоритм базується на двох процедурах: просіювання вверх та просіювання вниз (англ. heapify).
                Вони виконуються коли порушено умову двійкової купи, і потрібно заново її побудувати.
            </TextItem>
            <TextItem>
                    <div>Складність алгоритму - O(n ∙ log(n)).</div>
            </TextItem>
            
            <HorizontalLine/>
            
            <TextItem>Покроковий опис алгоритму сортування пірамідою:</TextItem>
            <TextItem tabs={1}>{"1. Повторювати крок 2-3 при i=0,1,...,n-1"}</TextItem>
            <TextItem tabs={2}>{"2. Дабавити елемент масиву за індексом i у кінець дерева"}</TextItem>
            <TextItem tabs={2}>{"3. Просіяти вверх щойно доданий (останній) елемент"}</TextItem>
            <TextItem tabs={1}>{"4. Повторювати кроки 5-7 при i=n-1,n-2,...,1"}</TextItem>
            <TextItem tabs={2}>{"5. Переставити місцями кореневу вершину і останню (Розміщення найбільшого елементу в кінець)"}</TextItem>
            <TextItem tabs={2}>{"6. Помітити останній елемент як відсортований, і видалити (забути про його існування) його з дерева"}</TextItem>
            <TextItem tabs={2}>{"7. Викликати процедуру просіювання вниз для кореня"}</TextItem>

            <HorizontalLine/>

            <TextItem>Покроковий опис алгоритму просіювання вниз:</TextItem>
            <TextItem tabs={1}>{"1. Присвоїти вершину, яку потрібно просіяти, у змінну largest"}</TextItem>
            <TextItem tabs={1}>{"2. Якщо лівий син поточної вершини більший за largest, то присвоїти його в змінну largest"}</TextItem>
            <TextItem tabs={1}>{"3. Якщо правий син поточної вершини більший за largest, то присвоїти його в змінну largest"}</TextItem>
            <TextItem tabs={1}>{
                `4. Якщо відбувся крок 2 або 3, то переставити місцями вершину яку потрібно просіяти із вершиною, що у змінній largest,
                та викликати процедуру просіювання вниз для вершини largest`
            }</TextItem>

            <HorizontalLine/>

            <TextItem>Покроковий опис алгоритму просіювання вверх:</TextItem>
            <TextItem tabs={1}>{"1. Якщо у вершини, яку потрібно просіяти, немає батька - завершити алгоритм"}</TextItem>
            <TextItem tabs={1}>{"2. Якщо у батька даної вершини значення більше, або таке ж - завершити алгоритм"}</TextItem>
            <TextItem tabs={1}>{"3. Переставити місцями значення даної вершини і її батька"}</TextItem>
            <TextItem tabs={1}>{"3. Викликати процедуру просіювання вверх для батька"}</TextItem>
        </>
    );
}

export default HeapSortInfo;