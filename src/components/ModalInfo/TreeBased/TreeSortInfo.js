import TextItem from "../TextItem"
import HorizontalLine from "../HorizontalLine"

function TreeSortInfo() {
    return (
        <>
            <TextItem>
                Алгоритм полягає в створенні бінарного дерева пошуку - бінарне дерево, ключ у кожному вузлі якого більший за будь-який ключ, 
                що зберігається в лівому піддереві, і менший або дорівнює будь-якому ключу, що зберігається в правому піддереві.
            </TextItem>

            <TextItem>
                Якщо обійти таке дерево в змішаному порядку (змішаний обхід), отримаємо відсортований масив.
            </TextItem>
            
            <TextItem>
                Головним недоліком алгоритму є його нестабільність. 
                Складність додавання нової вершини в бінарне дерево пошуку варіюється від O(log(n)) до O(n),
                що може збільшити загальну алгоритмічну складність.
                Найгірший випадок сортування - коли всі елементи масиву вже відсортовані, 
                у такому випадку, час роботи алгоритму дорівнює O(n<sup>2</sup>).
            </TextItem>

            <TextItem><div>Середня складність алгоритму - O(n ∙ log(n)).</div></TextItem>

            <HorizontalLine/>
            
            <TextItem>Покроковий опис сортування бінарним деревом:</TextItem>
            <TextItem tabs={1}>{"1. Повторювати крок 2 при i=0,1,...,n-1"}</TextItem>
            <TextItem tabs={2}>{"2. Добавити елемент масиву за індексом i у бінарне дерево пошуку"}</TextItem>
            <TextItem tabs={1}>{"3. Виконати змішаний обхід дерева"}</TextItem>

            <HorizontalLine/>

            <TextItem>Покроковий опис додавання елемента в бінарне дерево пошуку:</TextItem>
            <TextItem tabs={1}>{"1. Якщо дерево пусте, встановити елемент коренем, завершити алгоритм"}</TextItem>
            <TextItem tabs={1}>{"2. Якщо елемент менший за поточну вершину, перейти до кроку 3, інакше до кроку 4"}</TextItem>
            <TextItem tabs={2}>{`3. Якщо лівого сина немає, добавити його зі значенням елемента та завершити алгоритм,
                інакше виконати цей алгоритм над лівим сином`
            }</TextItem>
            <TextItem tabs={2}>{`4. Якщо правого сина немає, добавити його зі значенням елемента та завершити алгоритм,
                інакше виконати цей алгоритм над правим сином`
            }</TextItem>


        </>
    );
}

export default TreeSortInfo;