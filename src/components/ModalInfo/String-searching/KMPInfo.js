import TextItem from "../TextItem"
import HorizontalLine from "../HorizontalLine"

function KMPInfo() {
    return (
        <>
            <TextItem>
                Алгоритм використовує просте спостереження, що коли відбувається невідповідність, 
                то зразок містить у собі достатньо інформації для того, щоби визначити, 
                де наступне входження може початися. У такий спосіб пропускається кількаразова перевірка попередньо порівняних символів.
            </TextItem>
            <TextItem>
                Попередньо проводиться дослідження зразка: для кожного його підрядка визначається префікс-суфікс-функція. 
                Для цього вираховується найдовший початок підрядка, який збігається з його кінцем.
            </TextItem>
            <TextItem>Складність алгоритму - O(n+m), де n — довжина тексту, m — довжина зразка.</TextItem>

            <HorizontalLine/>

            <TextItem>Покроковий опис алгоритму пошуку КМП (P - зразок, T - текст):</TextItem>
            <TextItem tabs={1}>
                1. Препроцесінг зразка: обрахувати префікс-суфікс-функцію для кожного підрядка зразка. 
                У результаті отримаємо масив lps, зі значеннями для кожного підрядка
            </TextItem>
            <TextItem tabs={1}>2. Присвоїти i = 0 (індекс тексту); j = 0 (індекс зразка)</TextItem>
            <TextItem tabs={1}>3. Порівнюємо P[j] та T[i+j]. Якщо збіг - перейти до кроку 4, інакше перейти до 6-го кроку</TextItem>
            <TextItem tabs={2}>{"4. Якщо j == m-1, то алгоритм завершено, зразок знайдено"}</TextItem>
            <TextItem tabs={2}>{"5. Присвоїти j = j+1. Якщо i+j<=n, перейти до кроку 3, інакше алгоритм завершено, зразок не знайдено"}</TextItem>
            <TextItem tabs={2}>{"6. Присвоїти i = i+j-lps[j]; j = 0.  Якщо i<=n-m, перейти до кроку 3, інакше алгоритм завершено, зразок не знайдено"}</TextItem>
        </>
    );

}

export default KMPInfo;

