import TextItem from "../TextItem"
import HorizontalLine from "../HorizontalLine"

function BoyerMooreInfo() {
    return (
        <>
            <TextItem>
                Ефективний алгоритм пошуку рядка, який є еталоном при практичних дослідженнях алгоритмів пошуку рядка.
                Порівняння символів починається з кінця зразка, а не з початку.
            </TextItem>
            <TextItem>
                Попередньо проводиться дослідження зразка та для кожного його елементу визначається стоп-символ - 
                це символ в тексті, який є першим неспівпадінням тексту і зразка при порівнянні справа (з кінця зразка).
            </TextItem>
            <TextItem>Складність алгоритму - O(n/m), де n — довжина тексту, m — довжина зразка.</TextItem>

            <HorizontalLine/>

            <TextItem>Покроковий опис алгоритму пошуку Боєра - Мура (P - зразок, T - текст):</TextItem>
            <TextItem tabs={1}>{`
                1. Препроцесінг зразка: Обрахувати стоп-символ для кожного елементу зразка. 
                В результаті отримаємо масив badchar, зі значеннями для кожного символу
            `}</TextItem>
            <TextItem tabs={1}>{`2. Присвоїти i = 0 (індекс тексту)`}</TextItem>
            <TextItem tabs={1}>{`3. Присвоїти j = m-1`}</TextItem>
            <TextItem tabs={1}>{`4. Поки j >= 0 повторювати крок 5:`}</TextItem>
            <TextItem tabs={2}>{`5. Якщо P[j] == T[i+j], то присвоїти j = j-1`}</TextItem>
            <TextItem tabs={1}>{`6. Якщо j < 0, то зразок знайдено, алгоритм завершено`}</TextItem>
            <TextItem tabs={1}>{`7. Якщо символ T[i+j] є в зразку, то присвоїти i = i + j - badchar[T[i+j]], інакше присвоїти i = i + 1`}</TextItem>
            <TextItem tabs={1}>{`8. Якщо i <= n-m, то перейти до кроку 3. Інакше алгоритм завершено, зразок не знайдено`}</TextItem>
            
        </>
    );

}

export default BoyerMooreInfo;

